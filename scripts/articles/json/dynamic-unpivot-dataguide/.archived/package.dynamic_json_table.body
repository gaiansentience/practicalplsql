create or replace package body dynamic_json_table as

    function get_columns(
        p_jdoc in clob
        , p_object_id in varchar2 default 'id'
        , p_rows_path in varchar2 default null
    ) return t_columns
    is
        l_columns t_columns;
        l_replace_name varchar2(100);
        l_replace_path varchar2(100);
    begin
    
        if p_rows_path is not null then
            l_replace_path := '.' || p_rows_path;
            l_replace_name := '$.' || p_rows_path || '.';
        else
            l_replace_path := null;
            l_replace_name := '$.';
        end if;
        
        with json_base as (
            select p_jdoc as jsource
            from dual
        ), dataguide_base as (
            select json_dataguide(b.jsource) as jdg
            from json_base b
        ), columns_base as (
            select
                replace(c.column_path, l_replace_name) as column_name
                , c.column_type
                , replace(c.column_path, l_replace_path) as column_path
            from 
                dataguide_base b,
                json_table(b.jdg,'$[*]' 
                    columns(
                        column_path varchar2(1000) path '$."o:path"'
                        , column_type varchar2(100) path '$.type'
                        )
                ) c
        )
        select column_name, column_type, column_path
        bulk collect into l_columns
        from columns_base
        where 
            upper(column_name) <> upper(nvl(p_object_id,'~#~#~'))
            and column_name not like '%[*]%'
            and column_type not in ('array','object')
        order by column_name;
    
        return l_columns;
    
    end get_columns;
    
    function quote_identifier(p_name in varchar2, p_alias in varchar2 default null) return varchar2
    is
    begin
        return case when p_alias is not null then p_alias || '.' end || '"' || p_name || '"';
    end quote_identifier;

    function get_sql(
        p_jdoc in clob
        , p_object_id in varchar2 default 'id'
        , p_rows_path in varchar2 default null
    ) return varchar2
    is
        l_cols t_columns;
        l_sql varchar2(32000);
        l_cols_rel_select varchar2(32000);
        l_json_path varchar2(100);
        l_cols_json_table varchar2(32000);
        l_cols_unpivot varchar2(32000);
        l_indent varchar2(100);
    begin
    
        l_cols := get_columns(p_jdoc, p_object_id, p_rows_path);
        dbms_output.put_line(l_cols.count || ' attributes found');
    
        l_cols_rel_select := quote_identifier(nvl(p_object_id, 'id#ordinality'), 'j') || chr(10);
        l_indent := '                , ';
        for i in 1..l_cols.count loop
            l_cols_rel_select := l_cols_rel_select || l_indent || quote_identifier(l_cols(i).column_name, 'j') || chr(10);
        end loop;
    
        l_json_path := '''$' || case when p_rows_path is not null then '.' || p_rows_path end || '[*]''';
        
        if p_object_id is not null then
            l_cols_json_table := quote_identifier(p_object_id) || ' number path ''$.' || p_object_id || '''' || chr(10);
        else
            l_cols_json_table := quote_identifier('id#ordinality') || ' for ordinality' || chr(10);
        end if;
        l_indent := '                    , ';        
        for i in 1..l_cols.count loop
            l_cols_json_table := l_cols_json_table || l_indent || quote_identifier(l_cols(i).column_name) || ' path ''' || l_cols(i).column_path || '''' || chr(10);
        end loop;

        l_indent := '                    , ';
        for i in 1..l_cols.count loop
            l_cols_unpivot := l_cols_unpivot || case when i > 1 then l_indent end || quote_identifier(l_cols(i).column_name) || chr(10);
        end loop;
    
        l_sql := '
        with json_base as (
            select :j as jdoc
            from dual
        ), relational_base as (
            select 
                ##COLS_REL_SELECT##
            from 
                json_base b,
                json_table(b.jdoc format json, ##JSON_PATH## 
                    columns (
                    ##COLS_JSON_TABLE##
                    )
                ) j
        )
        select ' || quote_identifier(nvl(p_object_id,'id#ordinality')) || ', "object#key", "object#value"
        from 
            relational_base
            unpivot (
                "object#value" for "object#key" in (
                    ##COLS_UNPIVOT##
                )
            )
        ';
        
        l_sql := replace(l_sql,'##COLS_REL_SELECT##', l_cols_rel_select);
        l_sql := replace(l_sql,'##JSON_PATH##', l_json_path);
        l_sql := replace(l_sql,'##COLS_JSON_TABLE##', l_cols_json_table);
        l_sql := replace(l_sql,'##COLS_UNPIVOT##', l_cols_unpivot);
        
        
        --dbms_output.put_line(l_sql);

        return l_sql;
    end get_sql;

    function unpivot_json(
        p_jdoc in clob
        , p_object_id in varchar2 default 'id'
        , p_rows_path in varchar2 default null
    ) return t_attributes pipelined
    is
        l_cols t_columns;
        l_sql varchar2(32000);
        rc sys_refcursor;
        l_attribs t_attributes;
    begin
    
        l_sql := get_sql(p_jdoc, p_object_id, p_rows_path);
        
        open rc for l_sql using p_jdoc;
        
        loop
        
            fetch rc bulk collect into l_attribs limit 1000;
            exit when l_attribs.count = 0;
        
            for i in 1..l_attribs.count loop
                pipe row (l_attribs(i));
            end loop;
            
        end loop;
        
        close rc;
        
        return;
    
    end unpivot_json;

end dynamic_json_table;
